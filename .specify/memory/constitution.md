<!--
SYNC IMPACT REPORT
==================
Version Change: 2.0.0 â†’ 3.0.0
Bump Rationale: MAJOR - Added Phase IV Addendum with new governance rules for deployment scope,
database schema immutability, and AI-assisted DevOps boundaries

Modified Sections:
- Section 8: Updated Phase IV status from "Future" to "ACTIVE" with expanded description
- Section 9: Added Phase IV Constraints reference (9.4)
- Section 13: Updated Override Precedence to include Phase IV Addendum

Added Sections:
- Section 15: Phase IV Addendum (complete deployment governance framework)
  - 15.1 Phase IV Purpose
  - 15.2 Phase IV Core Principles (4 subsections)
  - 15.3 Phase IV Standards (4 categories, 32 rules)
  - 15.4 Phase IV Architecture Constraints
  - 15.5 Phase IV Prohibited Operations
  - 15.6 Phase IV Permitted Operations
  - 15.7 Phase IV Override Precedence
  - 15.8 Phase IV Success Criteria
  - 15.9 Phase IV Completion Checklist

Removed Sections:
- None

Templates Requiring Updates:
- .specify/templates/plan-template.md âš ï¸ PENDING (Constitution Check needs Phase IV alignment)
- .specify/templates/tasks-template.md âš ï¸ PENDING (Phase constraints need Phase IV rules)

Follow-up TODOs:
- Update plan-template.md Constitution Check to include Phase IV deployment-only constraints
- Update tasks-template.md to reference Phase IV infrastructure task types
-->

# Project Constitution
## Hackathon: The Evolution of Todo (Phases Iâ€“IV)

---

## 1. Purpose & Vision

The purpose of this project is to build a Todo application that evolves from a simple in-memory console program into a fully distributed, cloud-native, AI-powered system.

This project is not about writing code manually. It is about mastering **Spec-Driven Development**, **Reusable Intelligence**, and **AI-Native Architecture**, where AI agents generate implementations based on precise, well-governed specifications.

The long-term vision is to demonstrate how modern software systems can be designed by humans as architects, while AI agents act as skilled implementers.

---

## 2. Core Principles (Non-Negotiable)

### 2.1 Spec-First Development

- Every feature MUST begin with a written specification
- No code shall exist without a corresponding spec
- Specifications are the single source of truth
- If implementation conflicts with spec â†’ spec wins
- If behavior is unclear â†’ spec MUST be updated

### 2.2 No Manual Coding

- Human-written production code is strictly forbidden
- All implementation MUST be generated by Claude Code using Spec-Kit Plus
- If output is incorrect, the specification MUST be refined â€” not the code
- Direct ad-hoc edits to generated code are prohibited

### 2.3 Reusable Intelligence

- Intelligence MUST be abstracted into **Agents** and **Skills**
- Skills MUST be reusable across phases and features
- Behavior belongs to agents; execution belongs to tools
- Skills MUST be composable and phase-agnostic
- Skills MUST NOT depend on UI or infrastructure details

### 2.4 Deterministic Architecture

- System behavior MUST be predictable and testable
- AI agents MUST follow explicit behavioral rules defined in specs
- Hidden or implicit logic is NOT allowed
- Given the same state and input, behavior MUST be reproducible

### 2.5 Progressive Evolution

- Each phase builds strictly on the previous phase
- No phase may be skipped
- Complexity increases gradually: CLI â†’ Web â†’ AI â†’ Cloud â†’ Distributed

---

## 3. Architectural Philosophy

### 3.1 Separation of Responsibilities

| Layer | Responsibility |
|-------|----------------|
| **Specifications** | Define *what* and *why* |
| **Agents** | Decide *how* |
| **Skills** | Define *capabilities* |
| **Tools** | Perform *actions* |
| **Infrastructure** | Execute *at scale* |

### 3.2 Agent-Centric Design

- Agents act as decision-makers
- Agents MUST NOT directly manipulate databases or infrastructure
- Agents interact with the system exclusively through tools

### 3.3 Skill-Driven Intelligence

- Skills represent reusable cognitive abilities
- Skills MUST be clearly named and scoped
- Agent behavior MUST be explainable
- Tool usage MUST be transparent

---

## 4. Specification Governance

### 4.1 Spec Structure

All specifications MUST live inside the `/specs` directory and follow Spec-Kit conventions.

Specs MUST be categorized as:
- Feature specs (user-facing behavior)
- Agent & skill specs (intelligence)
- API specs (contracts)
- Data specs (models & schemas)
- Infrastructure specs (deployment behavior)

### 4.2 Spec Authority

- If implementation conflicts with spec â†’ spec wins
- If behavior is unclear â†’ spec MUST be updated
- Claude Code MUST always be instructed via spec references

---

## 5. Forward Compatibility Guarantees

The system MUST be designed such that:

- Phase-I logic can be reused by:
  - Web APIs (Phase-II)
  - MCP tools (Phase-III)
  - Event handlers (Phase-V)

- Task operations remain:
  - Stateless
  - Deterministic
  - Tool-compatible

- No decision in any phase should block:
  - AI agent control
  - Kubernetes deployment
  - Event-driven execution

---

## 6. Quality Standards

### 6.1 Code Quality

- Clean, readable, modular structure
- Single responsibility per module
- Explicit error handling

### 6.2 Intelligence Quality

- Skills MUST be clearly named and scoped
- Agent behavior MUST be explainable
- Tool usage MUST be transparent

### 6.3 Documentation

- Every phase MUST update specs
- README MUST reflect current phase
- CLAUDE.md MUST guide AI behavior

---

## 7. Technology Stack Governance

The following technology stack is constitutionally approved. Substitutions are NOT permitted without constitutional amendment.

### Core Development

| Component | Technology |
|-----------|------------|
| Language (Backend) | Python 3.13+ |
| Frontend Framework | Next.js (App Router) |
| AI Coding Assistant | Claude Code |
| Spec Management | Spec-Kit Plus |

### Backend & Data

| Component | Technology |
|-----------|------------|
| API Framework | FastAPI |
| ORM | SQLModel |
| Database | Neon Serverless PostgreSQL |

### AI & Intelligence

| Component | Technology |
|-----------|------------|
| AI Framework | OpenAI Agents SDK |
| Tool Protocol | Model Context Protocol (MCP) |
| Chat UI | OpenAI ChatKit |

### Cloud & Infrastructure

| Component | Technology |
|-----------|------------|
| Containerization | Docker |
| Orchestration | Kubernetes |
| Local Cluster | Minikube |
| Package Manager | Helm 3.x |
| Event Streaming | Kafka (Redpanda compatible) |
| Distributed Runtime | Dapr |

---

## 8. Project Phases (Authoritative Roadmap)

This project SHALL be executed strictly in the following phases. Each phase builds upon the previous one and no phase may be skipped.

### Phase I â€” In-Memory Console Application âœ… FROZEN

- **Objective**: Establish core task management logic
- **Interface**: Command-line (CLI)
- **Persistence**: In-memory only
- **Intelligence**: No autonomous agent; future agent compatibility required
- **Status**: Complete and immutable

### Phase II â€” Full-Stack Web Application âœ… FROZEN

- **Objective**: Introduce persistence, multi-user support, and authentication
- **Interface**: Web (Frontend + REST API)
- **Persistence**: PostgreSQL (Neon Serverless)
- **Intelligence**: Rule-based system only
- **Status**: Complete and immutable

### Phase III â€” AI-Powered Todo Chatbot âœ… FROZEN

- **Objective**: Enable natural language task management
- **Interface**: Conversational UI (Chat)
- **Intelligence**: OpenAI Agents with MCP tools
- **Architecture**: Stateless server with persisted conversation state
- **Status**: Complete and immutable

### Phase IV â€” Local Cloud-Native Deployment ðŸš§ ACTIVE

- **Objective**: Containerize and deploy on local Kubernetes
- **Interface**: Kubernetes services via Helm charts
- **Intelligence**: AI-assisted DevOps (specification generation only)
- **Architecture**: Docker containers orchestrated by Minikube
- **Database**: External PostgreSQL (NOT containerized)
- **Scope**: Deployment and infrastructure ONLY â€” no application changes
- **Status**: Active development

### Phase V â€” Advanced Distributed Cloud System (Future)

- **Objective**: Implement event-driven architecture
- **Interface**: Cloud-native microservices
- **Intelligence**: Event-driven agents and orchestration

---

## 9. Phase-Specific Scope

### 9.1 Phase I Constraints (FROZEN)

- No databases
- No web interfaces
- No AI chatbot
- No external services
- No autonomous agents for business logic
- Governance agents permitted strictly for specification validation

### 9.2 Phase II Constraints (FROZEN)

- PostgreSQL persistence required
- REST API interface
- Multi-user support with authentication
- Rule-based logic only (no AI agents)
- Phase I logic MUST be preserved and extended

### 9.3 Phase III Constraints (FROZEN)

See **Section 14: Phase III Addendum** for complete rules.

### 9.4 Phase IV Constraints (ACTIVE)

See **Section 15: Phase IV Addendum** for complete rules.

---

## 10. Success Criteria

This project is successful if:

- All phases are completed strictly via specs
- Agents and skills are reusable and well-defined
- The system scales from CLI to cloud without rewrites
- The final chatbot can manage todos naturally and reliably
- The architecture reflects production-grade AI-native design

---

## 11. Constitutional Amendment Rule

This constitution may only be modified by:

- Explicit versioned updates
- Clear justification in documentation
- Maintaining backward compatibility with previous phases

Uncontrolled or ad-hoc changes are NOT permitted.

---

## 12. Final Declaration

This project treats AI not as a tool, but as a **collaborating engineer**. The human role is to design intent, constraints, and architecture. The AI role is to implement faithfully within those boundaries.

This constitution governs all decisions, specs, and implementations for the lifetime of the project.

---

## 13. Override Precedence

When conflicts arise between rules, the following precedence applies (highest to lowest):

1. **Phase IV Addendum** (Section 15) â€” for Phase IV development only
2. **Phase III Addendum** (Section 14) â€” for Phase III development only
3. **Core Principles** (Section 2) â€” non-negotiable across all phases
4. **Technology Stack Governance** (Section 7) â€” approved technologies
5. **Phase-Specific Scope** (Section 9) â€” phase constraints
6. **Architectural Philosophy** (Section 3) â€” design patterns
7. **Quality Standards** (Section 6) â€” implementation quality

**Rule**: When a phase-specific addendum rule contradicts a general rule, the addendum rule takes precedence for that phase's development. General rules apply when the addendum is silent.

---

## 14. Phase III Addendum

> **Scope**: This addendum governs Phase III development exclusively. These rules extend and, where explicitly stated, override general constitutional provisions for Phase III.

### 14.1 Phase III Purpose

Phase III governs the design, implementation, and validation of a fully functional, AI-driven conversational todo management system built using MCP architecture, OpenAI Agents SDK, and a stateless FastAPI backend.

**Focus Areas**:
- Correctness
- Traceability
- Agent-tool alignment
- Reproducible behavior across stateless requests

### 14.2 Phase III Core Principles

#### 14.2.1 Spec-First Fidelity (Reinforced)

All system behavior MUST originate from written specifications.

- No implementation is permitted without an explicit spec definition
- Specs are the single source of truth for agent behavior, MCP tools, and API flows
- Changes to behavior require spec amendments before code changes

#### 14.2.2 Agent-Tool Determinism (NEW)

AI agents MUST act only through MCP tools for task manipulation.

- No hidden state, implicit memory, or side-channel logic is allowed
- Every state change MUST be attributable to a tool invocation
- Free-form hallucinated responses that bypass tools are DISALLOWED
- Agents MUST NOT fabricate task IDs or task states
- Agents MUST query before destructive actions when ambiguity exists

#### 14.2.3 Statelessness with Persistent Memory (NEW)

Backend servers and MCP tools MUST remain stateless across requests.

- All conversational and task state MUST be persisted in the database
- System behavior MUST be fully recoverable after server restart
- No in-memory session state is permitted
- Conversation context MUST be reconstructed from database on every request

#### 14.2.4 Observability & Traceability (NEW)

Every user action MUST map to a traceable execution chain:

```
user message â†’ agent decision â†’ MCP tool call â†’ database mutation â†’ response
```

- Tool calls MUST be explicitly returned in API responses for auditability
- All operations MUST be logged with sufficient detail for debugging

#### 14.2.5 Reproducibility (Reinforced)

Given the same database state and user input, agent behavior MUST be reproducible.

- Prompts, specs, and agent configuration MUST be version-controlled
- Non-deterministic behavior MUST be documented and justified
- The full spec-driven workflow MUST be documented and reviewable

### 14.3 Phase III Standards

#### Specification Standards

Separate specs MUST exist for:
- Agent behavior
- MCP tool contracts
- API request/response lifecycle

Specs MUST define:
- Trigger conditions
- Expected tool usage
- Error handling behavior

#### Agent Standards

- Agents MUST use **OpenAI Agents SDK** exclusively
- Agents MUST select tools based on intent classification
- Agents MUST confirm all state-changing actions
- Agents MUST gracefully handle missing or invalid tasks
- Agents MUST NOT store memory internally

#### MCP Standards

- MCP server MUST use the **Official MCP SDK**
- Each tool MUST be stateless
- Each tool MUST be idempotent where applicable
- Each tool MUST be fully validated against input schema
- Tools may ONLY read/write via the database layer

#### API Standards

- Single stateless endpoint: `POST /api/{user_id}/chat`
- Conversation context MUST be reconstructed from database on every request
- API responses MUST include:
  - `conversation_id`
  - Assistant response
  - List of MCP tool calls (if any)

### 14.4 Phase III Architecture Constraints

| Component | Required Technology |
|-----------|---------------------|
| Backend | Python FastAPI |
| AI Logic | OpenAI Agents SDK |
| MCP Server | Official MCP SDK |
| ORM | SQLModel |
| Database | Neon Serverless PostgreSQL |
| Authentication | Better Auth |
| Frontend | OpenAI ChatKit |

### 14.5 Phase III Data & Model Integrity

#### Database Integrity

- Tasks, conversations, and messages MUST be normalized and linked by `user_id`
- No orphaned messages or tasks are allowed
- All timestamps MUST be server-generated
- Foreign key constraints MUST be enforced

#### Conversation Integrity

- Every user message MUST be persisted BEFORE agent execution
- Every assistant message MUST be persisted AFTER agent execution
- Conversation continuity MUST survive server restarts
- Message ordering MUST be preserved via timestamps or sequence numbers

### 14.6 Phase III Implementation Constraints

- No manual coding outside the Agentic Dev Stack workflow
- All code MUST be generated through: `spec â†’ plan â†’ tasks â†’ Claude Code execution`
- Direct ad-hoc edits to generated code are prohibited
- Behavior MUST be reproducible and auditable via logs and tool calls
- The application MUST resume seamlessly after backend restarts

---

## 15. Phase IV Addendum

> **Scope**: This addendum governs Phase IV development exclusively. These rules extend and, where explicitly stated, override general constitutional provisions for Phase IV. All Phase I-III rules remain in effect unless explicitly superseded.

### 15.1 Phase IV Purpose

Phase IV governs the containerization, packaging, and local Kubernetes deployment of the Phase I-III application using Helm charts and AI-assisted DevOps practices.

**Focus Areas**:
- Deployment repeatability
- Environment parity (dev/staging/production patterns)
- Infrastructure-as-specification
- AI-assisted operational workflows

**Explicit Non-Goals**:
- Application feature development
- Business logic modifications
- Database schema changes
- User-facing functionality changes

### 15.2 Phase IV Core Principles

#### 15.2.1 Deployment-Only Scope (NEW)

Phase IV is strictly limited to deployment and infrastructure concerns.

- Application source code (frontend and backend) MUST NOT be modified for business logic
- All changes MUST be limited to deployment configuration, containerization, and orchestration
- Feature requests or bug fixes MUST be deferred to appropriate earlier phases
- Any proposed change that affects application behavior MUST be rejected and escalated

#### 15.2.2 Database Schema Immutability (NEW - ABSOLUTE)

Database schemas established in Phase I-III are immutable during Phase IV.

- **PROHIBITED**: Any migration, schema change, or DDL operation
- **PROHIBITED**: Adding, removing, or modifying tables, columns, indexes, or constraints
- **PROHIBITED**: Data transformations or seeding scripts that alter production data structure
- **PERMITTED**: Read-only database connectivity configuration
- **PERMITTED**: Environment-specific connection string management
- **PERMITTED**: Connection pooling and performance tuning at the connection level only

**Rationale**: Phase IV inherits a stable, tested data layer. Schema modifications would invalidate Phase I-III testing and introduce regression risk.

#### 15.2.3 Specification-Only Infrastructure (Reinforced)

All infrastructure decisions MUST be documented as specification artifacts before implementation.

- No Dockerfile, Helm chart, or Kubernetes manifest may exist without a corresponding spec
- Specs define WHAT should be deployed; implementation defines HOW
- Infrastructure changes require spec amendments before artifact changes
- AI-generated infrastructure code MUST be reviewed against specifications

#### 15.2.4 Stateless Application Preservation (Reinforced)

Phase III statelessness requirements MUST be preserved in containerized deployment.

- Backend containers MUST remain stateless across restarts
- No local filesystem persistence for application state
- All state MUST flow through the external PostgreSQL database
- Container restarts MUST NOT cause data loss or session corruption

### 15.3 Phase IV Standards

#### Containerization Standards

| Rule ID | Rule |
|---------|------|
| C-001 | Each deployable service MUST have a container specification document |
| C-002 | Container images MUST use multi-stage builds for production |
| C-003 | Base images MUST be pinned to specific versions (no `latest` tags) |
| C-004 | Container images MUST NOT include development dependencies |
| C-005 | Health check endpoints MUST be specified for all containers |
| C-006 | Environment variables MUST be the exclusive configuration mechanism |
| C-007 | Secrets MUST NOT be baked into container images |
| C-008 | Container specifications MUST document all exposed ports |

#### Kubernetes Deployment Standards

| Rule ID | Rule |
|---------|------|
| K-001 | Minikube is the required local Kubernetes environment |
| K-002 | All deployments MUST use Helm as the packaging and deployment unit |
| K-003 | Direct `kubectl apply` of raw manifests is PROHIBITED in production workflows |
| K-004 | Namespace isolation MUST be specified (e.g., `todo-dev`, `todo-staging`) |
| K-005 | Resource limits (CPU, memory) MUST be specified for all containers |
| K-006 | Liveness and readiness probes MUST be configured |
| K-007 | PostgreSQL MUST remain as an external service (not deployed in cluster) |
| K-008 | Service discovery MUST use Kubernetes DNS naming conventions |

#### Helm Standards

| Rule ID | Rule |
|---------|------|
| H-001 | Helm is the ONLY permitted deployment unit for Kubernetes |
| H-002 | Each service MUST have its own Helm chart |
| H-003 | All configurable values MUST be exposed via `values.yaml` |
| H-004 | Charts MUST support environment-specific value overrides |
| H-005 | Chart versions MUST follow semantic versioning |
| H-006 | Charts MUST include NOTES.txt with post-install instructions |
| H-007 | Charts MUST NOT contain hardcoded environment-specific values |
| H-008 | Helm release names MUST follow pattern: `{service}-{environment}` |

#### AI-Assisted DevOps Standards

| Rule ID | Rule |
|---------|------|
| A-001 | AI agents MAY assist with infrastructure specification generation |
| A-002 | AI agents MUST NOT execute deployment commands autonomously |
| A-003 | AI-generated specifications MUST be reviewed before implementation |
| A-004 | AI agents MUST operate through defined skills (containerization, helm-chart-design, etc.) |
| A-005 | AI agents MUST NOT modify application code under any circumstances |
| A-006 | AI agents MUST produce specification artifacts, not executable code |
| A-007 | Human approval is REQUIRED before any cluster-modifying operation |
| A-008 | AI agents MUST respect agent boundaries defined in Phase IV agent specifications |

### 15.4 Phase IV Architecture Constraints

| Component | Required Technology | Notes |
|-----------|---------------------|-------|
| Containerization | Docker | Specification-driven Dockerfiles |
| Orchestration | Kubernetes | Via Minikube for local development |
| Package Manager | Helm 3.x | Required deployment unit |
| Local Cluster | Minikube | Required local environment |
| Database | External PostgreSQL | NOT containerized; connection only |
| AI Assistance | Claude Code + Skills | Specification generation only |

### 15.5 Phase IV Prohibited Operations

The following operations are explicitly PROHIBITED during Phase IV:

| Category | Prohibited Operation |
|----------|---------------------|
| Database | Schema migrations or DDL changes |
| Database | Data seeding or transformation scripts |
| Database | Index creation or modification |
| Application | Business logic changes |
| Application | API endpoint additions or modifications |
| Application | Frontend feature changes |
| Application | Authentication flow modifications |
| Deployment | Raw kubectl apply in production |
| Deployment | Manual container image building without spec |
| Deployment | Helm chart creation without design spec |
| AI Agents | Autonomous command execution |
| AI Agents | Application code modification |

### 15.6 Phase IV Permitted Operations

The following operations are explicitly PERMITTED during Phase IV:

| Category | Permitted Operation |
|----------|---------------------|
| Configuration | Environment variable management |
| Configuration | Connection string configuration |
| Configuration | Resource limit tuning |
| Containerization | Dockerfile specification creation |
| Containerization | Multi-stage build design |
| Containerization | Health check endpoint specification |
| Helm | Chart structure design |
| Helm | values.yaml schema definition |
| Helm | Template specification |
| Kubernetes | Deployment strategy specification |
| Kubernetes | Service and ingress specification |
| Kubernetes | Namespace organization |
| Observability | Log aggregation configuration |
| Observability | Health monitoring setup |
| AI Assistance | Specification artifact generation |
| AI Assistance | Design review and validation |

### 15.7 Phase IV Override Precedence

When conflicts arise within Phase IV, the following precedence applies (highest to lowest):

1. **Database Schema Immutability** (15.2.2) â€” absolute, no exceptions
2. **Deployment-Only Scope** (15.2.1) â€” no application changes
3. **Phase IV Addendum Rules** (Section 15) â€” for Phase IV development
4. **Phase III Addendum Rules** (Section 14) â€” statelessness preservation
5. **Core Principles** (Section 2) â€” spec-first, no manual coding
6. **Technology Stack Governance** (Section 7) â€” approved technologies

**Rule**: Phase IV addendum rules take precedence for Phase IV development. Where Phase IV is silent, Phase III rules apply. Where both are silent, general constitutional rules apply.

### 15.8 Phase IV Success Criteria

Phase IV is successful when:

- All services are containerized with specification-driven Dockerfiles
- Helm charts exist for frontend and backend services
- Application deploys successfully to Minikube
- Application functionality matches Phase III behavior exactly
- No database schema changes occurred
- No application logic modifications occurred
- All deployments are repeatable via Helm
- AI agents operated within defined boundaries

### 15.9 Phase IV Completion Checklist

Before declaring Phase IV complete:

- [ ] Container specifications exist for all services
- [ ] Helm chart designs are documented and reviewed
- [ ] Minikube deployment is verified and repeatable
- [ ] Phase III functionality tests pass on deployed system
- [ ] Database connectivity is validated (read/write operations)
- [ ] No schema changes detected (schema diff = empty)
- [ ] Application code unchanged (source diff = configuration only)
- [ ] AI agent boundaries were respected throughout

---

**Version**: 3.0.0 | **Ratified**: 2025-12-30 | **Last Amended**: 2026-02-02
